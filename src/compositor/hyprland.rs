use std::collections::HashSet;
use std::path::{Path, PathBuf};

use crate::compositor::extraction::{ExtractionPlan, resolve_path};
use crate::compositor::position::ConfigPosition;

pub fn extract(config_path: &Path, output_filename: &str) -> Result<ExtractionPlan, String> {
    let config_path = config_path
        .canonicalize()
        .map_err(|e| format!("Cannot resolve config path: {e}"))?;

    let output_path = config_path
        .parent()
        .ok_or("Cannot determine config directory")?
        .join(output_filename);

    let mut extracted = Vec::new();
    let mut modified_files = Vec::new();
    let mut visited = HashSet::new();
    let mut source_exists = false;

    visited.insert(config_path.clone());

    parse_file(
        &config_path,
        &output_path,
        &mut extracted,
        &mut modified_files,
        &mut visited,
        &mut source_exists,
    )?;

    let output_content = if extracted.is_empty() {
        String::new()
    } else {
        let mut content = String::from("# Generated by xwlm. Do not edit manually.\n\n");
        for line in &extracted {
            content.push_str(line);
            content.push('\n');
        }
        content
    };

    let source_line = if !source_exists && !extracted.is_empty() {
        let source_path = get_source_path(&output_path);
        Some(format!("source = {}", source_path))
    } else {
        None
    };

    Ok(ExtractionPlan {
        output_content,
        modified_files,
        source_line,
        main_config: config_path,
        source_exists,
    })
}

fn get_source_path(output_path: &Path) -> String {
    let home = std::env::var("HOME").unwrap_or_default();

    if let Ok(stripped) = output_path.strip_prefix(&home) {
        let stripped_str = stripped.display().to_string();
        if stripped_str.starts_with('/') {
            format!("~{}", stripped_str)
        } else {
            format!("~/{}", stripped_str)
        }
    } else {
        output_path.display().to_string()
    }
}

fn parse_file(
    path: &Path,
    output_path: &Path,
    extracted: &mut Vec<String>,
    modified_files: &mut Vec<(PathBuf, String)>,
    visited: &mut HashSet<PathBuf>,
    source_exists: &mut bool,
) -> Result<(), String> {
    let content = std::fs::read_to_string(path)
        .map_err(|e| format!("Failed to read {}: {e}", path.display()))?;

    let mut kept_lines = Vec::new();
    let mut file_modified = false;
    let Some(base_dir) = path.parent() else {
        return Err(format!(
            "can't find the parent directory {}",
            path.display()
        ));
    };

    for line in content.lines() {
        let trimmed = line.trim();

        if trimmed.is_empty() || trimmed.starts_with('#') {
            kept_lines.push(line.to_string());
            continue;
        }

        if is_monitor_line(trimmed) || is_workspace_line(trimmed) {
            extracted.push(trimmed.to_string());
            file_modified = true;
            continue;
        }

        if let Some(source_path_str) = parse_source_line(trimmed) {
            let resolved = resolve_path(base_dir, &source_path_str);

            if let Ok(canonical) = resolved.canonicalize() {
                if canonical == output_path.canonicalize().unwrap_or_default() {
                    *source_exists = true;
                }

                if !visited.contains(&canonical) {
                    visited.insert(canonical.clone());
                    parse_file(
                        &canonical,
                        output_path,
                        extracted,
                        modified_files,
                        visited,
                        source_exists,
                    )?;
                }
            } else if resolved
                .file_name()
                .and_then(|f| output_path.file_name().map(|o| f == o))
                .unwrap_or(false)
            {
                *source_exists = true;
            }
        }

        kept_lines.push(line.to_string());
    }

    if file_modified {
        let new_content = kept_lines.join("\n");
        modified_files.push((path.to_path_buf(), new_content));
    }

    Ok(())
}

fn is_monitor_line(line: &str) -> bool {
    let lower = line.to_ascii_lowercase();
    if !lower.starts_with("monitor") {
        return false;
    }
    let rest = line["monitor".len()..].trim_start();
    rest.starts_with('=')
}

fn is_workspace_line(line: &str) -> bool {
    let lower = line.to_ascii_lowercase();
    if !lower.starts_with("workspace") {
        return false;
    }
    let rest = line["workspace".len()..].trim_start();
    rest.starts_with('=')
}

fn parse_source_line(line: &str) -> Option<String> {
    let lower = line.to_ascii_lowercase();
    if !lower.starts_with("source") {
        return None;
    }
    let rest = line["source".len()..].trim_start();
    if !rest.starts_with('=') {
        return None;
    }
    let path = rest[1..].trim();
    if path.is_empty() {
        return None;
    }
    Some(path.to_string())
}

pub fn config_position(content: &str, monitor_name: &str) -> Option<ConfigPosition> {
    let mut found_position: Option<ConfigPosition> = None;

    for line in content.lines() {
        let line = line.trim();

        // Skip comments and non-monitor lines
        if line.starts_with('#') || !line.starts_with("monitor") {
            continue;
        }

        // Strip "monitor" prefix and any surrounding whitespace/equals signs
        let line = line["monitor".len()..]
            .trim_start_matches([' ', '='])
            .trim();

        // Split into comma-separated parts
        let parts: Vec<&str> = line.split(',').map(|p| p.trim()).collect();

        // Must start with the target monitor name
        if parts.first().copied() != Some(monitor_name) {
            continue;
        }

        // Skip disabled entries, but don't stop â€” a later entry might re-enable it
        if parts.contains(&"disable") {
            continue;
        }

        // Position is the third field (index 2), formatted as "XxY"
        if let Some(pos_str) = parts.get(2)
            && let Some((x, y)) = parse_xy_position(pos_str)
        {
            found_position = Some(ConfigPosition { x, y });
        }
    }

    found_position
}

fn parse_xy_position(s: &str) -> Option<(i32, i32)> {
    let (x_str, y_str) = s.split_once('x')?;
    let x = x_str.trim().parse::<i32>().ok()?;
    let y = y_str.trim().parse::<i32>().ok()?;
    Some((x, y))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_source_path_with_home() {
        let home = std::env::var("HOME").unwrap_or_default();
        let path = PathBuf::from(format!("{}/.config/hypr/monitors.conf", home));
        let result = get_source_path(&path);
        assert_eq!(result, "~/.config/hypr/monitors.conf");
    }

    #[test]
    fn test_get_source_path_without_home() {
        let path = PathBuf::from("/etc/hypr/monitors.conf");
        let result = get_source_path(&path);
        assert_eq!(result, "/etc/hypr/monitors.conf");
    }

    #[test]
    fn test_is_monitor_line() {
        assert!(is_monitor_line("monitor=DP-1,1920x1080,0x0,1"));
        assert!(is_monitor_line("monitor = DP-1,1920x1080,0x0,1"));
        assert!(is_monitor_line("MONITOR=DP-1,1920x1080,0x0,1"));
        assert!(!is_monitor_line("monitors=DP-1"));
        assert!(!is_monitor_line("# monitor=DP-1"));
    }

    #[test]
    fn test_is_workspace_line() {
        assert!(is_workspace_line("workspace=1,monitor:DP-1"));
        assert!(is_workspace_line("workspace = 1,monitor:DP-1"));
        assert!(is_workspace_line("WORKSPACE=1,monitor:DP-1"));
        assert!(!is_workspace_line("workspaces=1"));
    }

    #[test]
    fn test_parse_source_line() {
        assert_eq!(
            parse_source_line("source = ~/.config/hypr/monitors.conf"),
            Some("~/.config/hypr/monitors.conf".to_string())
        );
        assert_eq!(
            parse_source_line("source=monitors.conf"),
            Some("monitors.conf".to_string())
        );
        assert_eq!(parse_source_line("source="), None);
        assert_eq!(parse_source_line("sourcemonitors.conf"), None);
    }
}
